"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _gsap = _interopRequireDefault(require("gsap"));

var _model = _interopRequireDefault(require("./model"));

var _emitter = _interopRequireDefault(require("./emitter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Scene {
  constructor() {
    this.emitter = new _emitter.default();
    this.scene = new THREE.Scene(); //this.scene.background = new THREE.Color( 0x1C1C1C );

    this.container = document.querySelector('canvas');
    this.perspective = 800;
    this.fov = 180 * (2 * Math.atan(window.innerHeight / 2 / this.perspective)) / Math.PI; //use for camera

    this.renderer = new THREE.WebGLRenderer({
      canvas: this.container,
      antialias: true,
      alpha: true
    });
    this.clock = new THREE.Clock(); //document.body.appendChild ( this.renderer.domElement );

    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.mouse = new THREE.Vector2(0, 0);
    this.initLights();
    this.initCamera();
    this.start();
    this.update();
    this.bindEvents();
  }

  on(event, callback) {
    this.emitter.on(event, callback);
  }

  start() {
    this.shoe = new _model.default(this);
    this.shoe.on('load', ev => this.emitter.emit('load', ev));
    this.shoe.on('complete', ev => this.emitter.emit('complete', ev));
  }

  initLights() {
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); //this.scene.add(ambientLight);

    const light = new THREE.PointLight(0xffffff, 2, 1000, 1);
    light.position.set(0, 200, 100);
    this.scene.add(light); // const helper = new THREE.PointLightHelper( light, 5 );
    // this.scene.add( helper );
  }

  initCamera() {
    this.camera = new THREE.PerspectiveCamera(this.fov, window.innerWidth / window.innerHeight, 1, 1000);
    this.camera.position.set(0, 0, this.perspective);
  }

  updateCamera() {
    this.camera.fov = this.fov;
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
  }

  onWindowResize() {
    this.updateCamera();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.shoe.onWindowResize();
  }

  onMouseMove(event) {
    _gsap.default.to(this.mouse, 0.5, {
      x: event.clientX,
      y: event.clientY
    });
  }

  update() {
    requestAnimationFrame(this.update.bind(this));
    this.renderer.render(this.scene, this.camera);
    this.shoe.update();
  }

  bindEvents() {
    if ('ontouchstart' in window) {
      document.addEventListener('touchmove', ev => this.onMouseMove(ev));
    } else {
      window.addEventListener('resize', () => this.onWindowResize());
      document.addEventListener('mousemove', ev => this.onMouseMove(ev));
    }
  }

  loadScene() {
    this;
  }

}

exports.default = Scene;